\chapter{Applications and infrastructure of eBPF}

eBPF can be addressed with various level of sophistication: anyone can start using eBPF based tools from some package, but writing an entire working eBPF program from scratch is a more complex task because it requires a lot of time to make things work, from installing the libraries to understand all the errors that will for sure occur when you try to compile the program.

In fact, integrating eBPF into modern applications and infrastructures can involve various levels of experience. 
Analyzing Linux kernel issues with eBPF, for instance, might demand significant kernel expertise, identifying relevant kernel functions and understanding their arguments.
While running an eBPF tool can be easy, understanding its output and choosing the right things to look at can present considerable challenges.

In this chapter we will address these challenges by reviewing a list of applications, in the form of their GitHub projects, that we have used to enter the world of eBPF, as they were either important to its evolution or were designed to make the development of programs easier.

For the curious people, on the \textit{eBPF.io} website \cite{eBPFioWebsite}, under the section \textit{Project landscape}, many other applications can be found and there is also a list of projects that represent the current major infrastructure of eBPF.

% APPLICATIONS AND INFRASTRUCTURE (USED)
%
% https://ebpf.io/applications/
% https://ebpf.io/what-is-ebpf/ -> development toolchains

\section{eBPF tools}

In the course of our research and experimentation, we opted to approach the world of eBPF from a slightly different angle. 
Rather than diving directly into eBPF tools and low-level programming, we began by leveraging existing frameworks that encapsulate the complexity of eBPF while providing a higher-level interface for achieving specific tracing and monitoring tasks.
This choice has been made at the beginning of our work because we wanted to study the state of art of eBPF today.
However, using eBPF based tools is the simplest way to approach the world of eBPF: for this reason, they need an honorable mention in this paper.

The easiest way is to learn what tools are available on the distribution that you are using: for example, the Ubuntu 20.04.01 (or later) system is provided with a \textit{bpfcc-tools} package that provides a few binaries to work with eBPF.
It is a collection of command-line tools and utilities that leverage the extended eBPF technology which are designed to simplify the process of working with eBPF programs, allowing users to gain insights into various aspects of system behavior, networking and security.
The \textit{bpfcc-tools} package is built on top of the \textit{BPF Compiler Collection} (\textit{bpfcc}), which offers a suite of tools for developing, deploying, and managing eBPF programs. 
It also provides pre-built and ready-to-use tools that cover a wide range of tracing and analysis use cases. 

Another list of raw observability tools to get started with eBPF can be found in the book \textit{BPF Performance Tools: Linux System and Application Observability} \cite{BPFToolsBookWebsite}, written by Brendan Gregg in 2019, and in its official GitHub repository \cite{BPFToolsBookGitHubRepo}: by presenting the utility, the capabilities and the value of different eBPF tools, the author hopes that the book can help the reader to improve performance, reduce costs and solve software issues of systems and applications.

eBPF tools are easy to use and very powerful, but there are a few characteristics that the beginner has to consider before using them:

\begin{itemize}
	\item They are commands that have to be invoked on the command line and they need 
		to be provided with some options and arguments (e.g. the events to which the tool has to react);
	\item You will be likely need to be root when you run the tools because the
		\textit{bpf()} system call checks for the appropriate capability;
	\item To stop the tool from running you have to press \textit{CTRL+C} or run them 
		with the timeout command, specifying the time in seconds;
	\item To write or use a tool you may need to be familiar with kernel data 
		structures or functions because, as we already mentioned in the portability problem, data structures can change based not only on kernel version, but also on kernel configuratiom and this may make the tool no longer work.
\end{itemize}

We just mentioned a couple of sources where anyone can find a list of tools to quickly access the benefits of eBPF technology without diving into the complexities of eBPF program development.
The most important thing is the fact that they provide a convenient way to access the power of eBPF-based tracing and analysis without needing to write eBPF programs from scratch. 
By offering a collection of readily available tools, they lower the barrier to entry for users who want to leverage eBPF technology to gain insights into their systems.

% https://sysdig.com/blog/sysdig-and-falco-now-powered-by-ebpf/ 
% -> eBPF ecosystem (bcc & bpftrace)
%
% bcc and bpftrace -> 2 main front ends for BPF performance tools

\section{bpftrace}

The next step in terms of complexity is to write some simple eBPF scripts: to do so, the easiest way is to use \textit{bpftrace}, one of the two biggest and most popular eBPF projects when it comes to tracing \cite{bpftraceRepo}.
It uses LLVM as a backend to compile scripts to eBPF-bytecode and it sits on top of BCC for interacting with the Linux eBPF system.
However, instead of requiring users to write their own programs against the BCC API, it offers a more expressive higher level syntax.

\textit{bpftrace} is a powerful dynamic tracing tool for Linux systems that utilizes a specialized tracing language to enable users to observe and analyze various aspects of system behavior (e.g. function calls, system calls and network events) and performance in real-time without the need for modifying or recompiling the kernel.
This simple scripting language, available in semi-recent Linux kernels (4.x), is designed to provide a concise and expressive way to create custom tracing scripts without requiring extensive knowledge of eBPF programming: it supports both ``one-liner'' commands for quick observations and complete scripts for more elaborate tracing scenarios.
It also comes with a collection of pre-built scripts, or ``one-liners'', that can be used for common tracing tasks or as examples to write more complex tools. 

In fact, one of the key advantages of \textit{bpftrace} is its ease of use. 
Its high-level scripting language abstracts the complexity of eBPF while still offering a wide range of tracing functionalities and a user-friendly syntax, making it accessible to a broader range of users. 
It consists of a set of commands, functions and existing Linux tracing capabilities and attachment points that allow users to specify what events they want to trace and how they want to capture and analyze the associated data.
This makes it easier to explore and troubleshoot system behavior, diagnose performance issues and gather insights into various aspects within the kernel and user-space applications.

\section{BCC}

% https://github.com/iovisor/bcc

To take the complexity of writing an eBPF tool or program one step further, we now have to analyze the other biggest and most popular eBPF project when it comes to tracing: \textit{BPF Compiler Collection} (BCC) \cite{BCCRepo}, a set of tools and libraries designed for working with eBPF programs in the Linux kernel.

This framework was invented before \textit{bpftrace}: in fact, writing eBPF programs with BCC could be significantly complicated due to the need to keep in mind a lot of assumptions about the way eBPF programs work.
However, even though moving from \textit{bpftrace} to BCC looks like a jump backwards, it is a very important step to do because it will be the beginner's first encounter with writing an eBPF program from scratch.
 
Actually, BCC simplifies the development, analysis and monitoring of eBPF-based applications by providing a user-friendly interface and a range of utilities. 
It includes various modules and libraries that allow developers to write, load and manage eBPF programs without needing deep kernel knowledge. 
In particular, BCC simplifies the process of compilation of an eBPF program from C using LLVM (with a C wrapper around it) as well as the actual mechanics of loading an eBPF program into the kernel and attaching it to the interested subsystem.
BCC also makes eBPF programs easier to write thanks to the provided interface to interact with eBPF consisting of high-level programming languages, such as Python and Lua, which allows programmers to create complex tracing and monitoring tools.

Additionally, BCC provides a set of pre-built tools and examples that can be used for one-off troubleshooting use cases typical of eBPF, such as performance analysis, network traffic control and system introspection.
However, it is important to note that much of what BCC uses requires Linux 4.1 and above.
For the reasons mentioned above and for the problem of portability of eBPF (as already discussed), BCC is a good choice when writing moderately complex eBPF programs.

\section{libbpf}

Finally, the last step in complexity to enter the eBPF world is to write an eBPF program in C or C++.
But before explaining how this can be done, it is crucial to introduce \textit{libbpf},
a critical component within the eBPF ecosystem, providing a user-space C/C++ based library designed to interact with the eBPF subsystem of the Linux kernel \cite{libbpfRepo}. 
The journey to the release of \textit{libbpf} was long and nowadays it is still maintained as part of the upstream Linux kernel: the ones that want to read more details about it and look at the major things that were introduced with this library can read the post on Andrii Nakryiko's blog \cite{libbpfJourney}.

Like BCC, it enables developers to write and manage eBPF programs from user-space applications without needing to deal directly with low-level kernel interfaces.
But throughout the years, \textit{libbpf} received a major boost in capabilities and sophistication and closed many existing gaps with BCC as a library.
Actually, there are a few advantages in using \textit{libbpf} instead of BCC.

The main thing about \textit{libbpf} is its role in standardizing and simplifying the development process of eBPF programs. 
It provides a consistent and stable API that shields developers from the complexities of interacting directly with the eBPF subsystem. 
In fact, as eBPF became popular across various domains, \textit{libbpf} ensures a smoother experience for programmers by offering a well-documented and well-maintained library for managing eBPF programs and resources \cite{libbpfDocumentation}, making it more accessible to a wider range of programmers.
This library encapsulates various functionalities:

\begin{itemize}
	\item The loader takes over processing eBPF ELF files generated from the 
		clang/LLVM compiler and loads eBPF programs into the kernel;
	\item Program verification and JIT compilation;
	\item It also supports important features not available in BCC such as global 
		variables and eBPF skeletons;
	\item Ease in the managements of eBPF maps;
	\item Abstracts the interaction with the \textit{bpf()} system call by providing 
		easy to use library APIs for applications.
\end{itemize}

Moreover, \textit{libbpf} is the canonical implementation of BPF CO-RE, the approach of writing eBPF application that solved the problem of portability of eBPF programs that we already discussed: in fact, it does not require Clang/LLVM runtime being deployed to target servers, it does not rely on kernel-devel headers being available and it does not introduce overhead of performing compilation in runtime on the target host, but it does rely on kernel to be built with BTF type information.
This feature allows the developer to get an eBPF program ``custom tailored'' to a kernel on target host as if his program was specifically compiled.

So, \textit{libbpf} is the latest and most advanced tool to work with eBPF: we encourage people new to ebpf as well as experienced ones new to this library to become familiar with it.
Since it is not the purpose of this thesis to describe in detail the \textit{libbpf} library, the curious people can go through the Linux kernel documentation page about \textit{libbpf} where they can find a few documents that provide a high-level understanding of the \textit{libbpf} APIs and their usage \cite{libbpfPageLinuxKernelDOc}.
In addition, for the ones that are used to work with BCC and want to switch to \textit{libbpf} there is a practical guide about converting a BCC-based eBPF application to \textit{libbpf} in an other post of Andrii Nakryiko's blog \cite{BCCTolibbpfGuide}.

For the reader's knowledge, during the project of this thesis all the examples of eBPF programs that were used to understand the functioning and the state of art of eBPF both on Linux and on Windows were created using this library.

\section{Bumblebee}

% https://github.com/solo-io/bumblebee

Create example to help develop in future.

\section{libbpf-bootstrap}

% https://github.com/libbpf/libbpf-bootstrap/tree/master

% https://nakryiko.com/posts/libbpf-bootstrap/

\section{ebpf for Windows}

% https://microsoft.github.io/ebpf-for-windows/ -> MANUAL PAGE

% https://github.com/Microsoft/ebpf-for-windows/ 

% https://github.com/SubconsciousCompute/windows-ebpf-starter
